<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>数据结构笔记04-复杂度分析（下）</title>
      <link href="/2018/11/29/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B004/"/>
      <url>/2018/11/29/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B004/</url>
      
        <content type="html"><![CDATA[<ul><li>最好、最坏情况时间复杂度</li><li>平均情况时间复杂度</li><li>均摊时间复杂度</li></ul><hr><a id="more"></a><h2 id="样例代码"><a class="markdownIt-Anchor" href="#样例代码"></a> 样例代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//n 表示数组array的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int pos = -1;</span><br><span class="line">    for (; i &lt; n; ++i) &#123;</span><br><span class="line">        if (array[i] == x) &#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最好-最坏情况时间复杂度"><a class="markdownIt-Anchor" href="#最好-最坏情况时间复杂度"></a> 最好、最坏情况时间复杂度</h2><p>为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度。</p><p>最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。当x正好是数组的第一个元素，这个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>就是最好情况时间复杂度。</p><p>最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。当x正好是数组的最后一个元素，这个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>就是最坏情况时间复杂度。</p><h2 id="平均情况时间复杂度"><a class="markdownIt-Anchor" href="#平均情况时间复杂度"></a> 平均情况时间复杂度</h2><p>要查找的变量x在数组的位置有n+1中情况：在数组的0~n-1位置中和不在数组中。我们把每种情况下需要遍历的元素个数累加求和，再除以n+1，得到需要遍历的平均值：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>n</mi><mo>+</mo><mi>n</mi></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mo>+</mo><mn>3</mn><mo>)</mo></mrow><mrow><mn>2</mn><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1+2+3+...+n+n}{n+1}=\frac{n(n+3)}{2(n+1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.427em;"></span><span class="strut bottom" style="height:2.363em;vertical-align:-0.936em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span><span class="mbin">+</span><span class="mord mathrm">2</span><span class="mbin">+</span><span class="mord mathrm">3</span><span class="mbin">+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">2</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span><span style="top:-0.2300000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit">n</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathrm">3</span><span class="mclose">)</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><p>时间复杂度的大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span></span></span></span>标记法中，可以省略掉系数、低阶、常量，所以平均时间复杂度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。</p><p>但是其实上面的计算过程稍微有点问题，因为n+1种情况出现的概率不同。如果我们把每种情况发生的概率考虑进去，假设在数组中和不在数组的概率都为1/2，要查找的数据出现在0~n-1的概率是一样的，为1/n，计算公式就变成了这样：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mo>+</mo><mn>2</mn><mo>×</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mo>+</mo><mn>3</mn><mo>×</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>n</mi><mo>×</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mo>+</mo><mi>n</mi><mo>×</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac><mo>=</mo><mfrac><mrow><mn>3</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mrow><mn>4</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">1\times\frac{1}{2n} + 2\times\frac{1}{2n} + 3\times\frac{1}{2n} +... + n\times\frac{1}{2n} + n\times\frac{1}{2}=\frac{3n+1}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.32144em;"></span><span class="strut bottom" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathrm">1</span><span class="mbin">×</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">2</span><span class="mord mathit">n</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">+</span><span class="mord mathrm">2</span><span class="mbin">×</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">2</span><span class="mord mathit">n</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">+</span><span class="mord mathrm">3</span><span class="mbin">×</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">2</span><span class="mord mathit">n</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mbin">×</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">2</span><span class="mord mathit">n</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mbin">×</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">4</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><p>这个值就是概率中的<strong>加权平均值</strong>，也叫作<strong>期望值</strong>，所以平均情况时间复杂度的全称应该是<strong>加权平均时间复杂度</strong>或者<strong>期望值时间复杂度</strong>。引入概率之后，用大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span></span></span></span>表示法来表示，这段代码的平均情况时间复杂度仍然是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。</p><p>大部分情况下，我们使用一个复杂度就可以满足需求了，只有同一块代码在不同情况下，时间复杂度有量级的差距，我们才会用这三种复杂度表示法来区分。</p><h2 id="均摊时间复杂度"><a class="markdownIt-Anchor" href="#均摊时间复杂度"></a> 均摊时间复杂度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// array表示一个长度为n的数组</span><br><span class="line">// 代码中的array.length就等于n</span><br><span class="line">int[] array = int[n];</span><br><span class="line">int count = 0;</span><br><span class="line"></span><br><span class="line">void insert(int val) &#123;</span><br><span class="line">    if (count == array.length) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i=0; i&lt;array.length; ++i) &#123;</span><br><span class="line">            sum = sum + array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        array[0] = sum;</span><br><span class="line">        count = 1</span><br><span class="line">    &#125;</span><br><span class="line">    array[count] = val;</span><br><span class="line">    ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现了一个往数组中插入数据的功能。当数组满了，清空数组，求和后的sum值放到第一个位置，再插入新的数据。如果一开始就有空闲空间，则直接插入。</p><p>这段代码的时间复杂度又是多少呢？</p><p>最好复杂度：数组有空闲空间，直接插入，所以是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>；最坏复杂度：数组已满，先做一次数组求和，所以是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></p><p>平均复杂度：假设数组长度是n，根据插入位置不同，我们有n种情况，每种情况复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>，还有一种额外的情况，数组已满，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，这n+1中情况发生的概率一样，都是1/(n+1)。所以，根据加权平均的计算方法，平均复杂度：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>+</mo><mn>1</mn><mo>×</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mn>1</mn><mo>×</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>+</mo><mi>n</mi><mo>×</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">1\times\frac{1}{n+1}+1\times\frac{1}{n+1}+...+1\times\frac{1}{n+1}+n\times\frac{1}{n+1}=O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.32144em;"></span><span class="strut bottom" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathrm">1</span><span class="mbin">×</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mbin">×</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mbin">×</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mbin">×</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></span></p><p>但是，其实这个例子里的平均复杂度分析不需要这么复杂，不需要引入概率论。对比一下这个insert()和前面那个find()的例子，有以下区别：</p><ol><li>insert()在大部分情况下，时间复杂度都为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，只有个别情况下，复杂度才比较高，为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>;</li><li>insert()函数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>时间复杂度的插入和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>时间复杂度的插入，出现的概率是非常有规律性的，而且有一定的前后顺序，一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的插入，紧跟着n-1个O(1)​的插入</li></ol><p>针对这种特殊的场景，可以引入一种更简单的分析方法：摊还分析法，通过摊还分析法得到的时间复杂度叫均摊时间复杂度。</p><p>分析过程：在这个数组中插入数据的例子，每一次<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的插入操作，都会跟着n-1次<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>的插入操作，所以把耗时多的那次操作平均摊到接下来的n-1次耗时少的操作上，均摊下来，这一组连续操作的时间复杂度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>。</p><p>均摊时间复杂度和摊还分析应用场景比较特殊，在能够应用均摊时间复杂度的场合，一般均摊时间复杂度等于最好时间复杂度。个人认为，均摊时间复杂度就是一种特殊的平均时间复杂度，我们应该掌握的是它的分析方法，摊还分析。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>极客时间-数据结构笔记03</title>
      <link href="/2018/11/27/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B003/"/>
      <url>/2018/11/27/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B003/</url>
      
        <content type="html"><![CDATA[<ul><li>为什么需要复杂度分析</li><li>大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span></span></span></span>复杂度表示法</li><li>时间复杂度分析</li><li>常见时间复杂度分析</li><li>空间复杂度分析</li><li>课后思考</li></ul><hr><a id="more"></a><h2 id="为什么需要复杂度分析"><a class="markdownIt-Anchor" href="#为什么需要复杂度分析"></a> 为什么需要复杂度分析</h2><p>通过统计和监控代码可以得到算法的执行时间和占用内存，这种方法叫<strong>事后统计</strong>，这种方法有很大的局限性：</p><ol><li>测试结果非常依赖测试环境</li><li>测试结果受数据规模的影响很大</li></ol><p>我们需要一个不用具体的测试数据测试就可以粗略估计算法执行效率的方法。</p><h2 id="大o复杂度表示法"><a class="markdownIt-Anchor" href="#大o复杂度表示法"></a> 大O复杂度表示法</h2><p>代码的执行都可以看出类似的操作：<strong>读数据-运算-写数据</strong>，所有代码的执行时间T(n)与每行代码的执行时间成正比。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n) = O(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p>这就是大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span></span></span></span>时间复杂度表示法，表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，叫作<strong>渐进时间复杂度</strong>，简称<strong>时间复杂度</strong></p><p>在采用大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span></span></span></span>标记复杂度的时候，可以忽略系数，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>C</mi><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(Cf(n)) = O(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><h2 id="时间复杂度分析"><a class="markdownIt-Anchor" href="#时间复杂度分析"></a> 时间复杂度分析</h2><p>如何分析一段代码的时间复杂度？以下是三个比较实用的方法：</p><ol><li><p>只关注循环执行次数最多的一段代码</p></li><li><p>加法法则：总复杂度等于量级最大的那段代码的复杂度</p>如果T1(n)=O(f(n)), T2(n)=O(g(n))，那么T(n)=O(max(f(n), g(n)))</li><li><p>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p>如果T1(n)=O(f(n)), T2(n)=O(g(n))，那么T(n)=O(f(n) * g(n))</li></ol><h2 id="常见时间复杂度分析"><a class="markdownIt-Anchor" href="#常见时间复杂度分析"></a> 常见时间复杂度分析</h2><p>常见的时间复杂度如下</p><img src="/2018/11/27/极客时间-数据结构笔记03/数据结构笔记03-1.jpeg" title="数据结构笔记03"><p>对于以上的时间复杂度，我们可以粗略分为两类：<strong>多项式量级</strong>和<strong>非多项式量级</strong>，非多项式量级只有两个：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>!</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></p><p>我们主要来看集中常见的<strong>多项式时间复杂度</strong></p><ol><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></p><p>只要算法中不存在循环语句、递归语句，即使有成百上千行代码，其时间复杂度也是O(1)​</p></li><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>是一种非常常见的算法时间复杂度，比如归并排序、快速排序等</p></li><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mbin">∗</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></p><p>代码的复杂度由<strong>两个数据的规模</strong>决定</p></li></ol><h2 id="空间复杂度分析"><a class="markdownIt-Anchor" href="#空间复杂度分析"></a> 空间复杂度分析</h2><p>空间复杂度的全称是<strong>渐进空间复杂度</strong>，表示<strong>算法的存储空间与数据规模之间的增长关系</strong>。</p><p>常见的空间复杂度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>，像<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>这样的对数阶复杂度平时用不到，空间复杂度分析比时间复杂度分析要简单很多。</p><h2 id="课后思考"><a class="markdownIt-Anchor" href="#课后思考"></a> 课后思考</h2><p>项目之前都会有性能测试，那代码的时间复杂度、空间复杂度是否多此一举？</p><p>时间复杂度、空间复杂度为我们提供了一个很好的理论分析的方向，是宿主平台无关的，能对不同的算法“效率”有一个感性的认识；但是实际上在不同的宿主环境，不同的数据集，真正的性能会不同。所以两者是相辅相成的，但是在编程中时刻关心时间、空间复杂度更有助于产出效率高的程序。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>极客时间-数据结构笔记02</title>
      <link href="/2018/11/26/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B002/"/>
      <url>/2018/11/26/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B002/</url>
      
        <content type="html"><![CDATA[<ul><li>数据结构和算法的概念</li><li>学习的重点</li><li>学习技巧</li></ul><hr><a id="more"></a><h2 id="数据结构和算法的概念"><a class="markdownIt-Anchor" href="#数据结构和算法的概念"></a> 数据结构和算法的概念</h2><p>从广义上讲，数据结构就是指一组数据的存储结构，算法就是操作数据的一组方法</p><p>从狭义上讲，就是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等</p><p>数据结构和算法是相辅相成的，数据结构是为算法服务的，算法要作用在特定的数据结构上。</p><h2 id="学习的重点"><a class="markdownIt-Anchor" href="#学习的重点"></a> 学习的重点</h2><ol><li><p>首先要掌握一个数据结构和算法中最重要的概念-复杂度分析</p></li><li><p>数据结构图谱：</p><img src="/2018/11/26/极客时间-数据结构笔记02/数据结构笔记02-1.jpeg" title="数据结构笔记02"><p>以上图谱中有20个最常用的、最基础的数据结构与算法，不管是应付面试还是工作需要，只要集中精力逐一攻克这20个知识点就足够了。</p><p><strong>10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树</strong></p><p><strong>10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法</strong></p></li><li><p>要学习它的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景”</p></li></ol><h2 id="学习技巧"><a class="markdownIt-Anchor" href="#学习技巧"></a> 学习技巧</h2><ol><li>边学边练，适度刷题。适度刷题，但一定不要浪费太多时间，学习的目的还是掌握，然后应用</li><li>多问、多思考、多互动</li><li>打怪升级学习法。在枯燥的学习过程中，可以给自己设立一个切实可行的目标，就像打怪升级一样</li><li>知识需要沉淀，不要试图一下子掌握所有。学习知识的过程是反复迭代、不断沉淀的过程。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python编程:从入门到实践-学习笔记1</title>
      <link href="/2018/11/22/Python%E7%BC%96%E7%A8%8B-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
      <url>/2018/11/22/Python%E7%BC%96%E7%A8%8B-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<p>Python编程：从入门到实践-学习笔记系列第一篇</p><ul><li>列表</li><li>if语句</li><li>字典</li><li>用户输入和while循环</li><li>函数</li><li>类</li><li>文件和异常</li><li>测试代码</li></ul><hr><a id="more"></a><h2 id="列表"><a class="markdownIt-Anchor" href="#列表"></a> 列表</h2><h4 id="列表简介"><a class="markdownIt-Anchor" href="#列表简介"></a> 列表简介</h4><ol><li>索引从0而不是从1开始</li><li>添加元素：append()末尾新增，insert()在指定位置新增</li><li>删除元素：del语句删除，pop()删除任何位置的元素，remove()删除值</li><li>组织列表：sort()永久性排序，sorted()临时排序，reverse()反转列表</li></ol><h4 id="操作列表"><a class="markdownIt-Anchor" href="#操作列表"></a> 操作列表</h4><ol><li><p>避免缩进错误，Python根据缩进来判断代码行和前一个代码行的关系</p></li><li><p>for语句末尾有冒号</p></li><li><p>使用range()函数创建数字列表，可使用list()将range()结果转为列表</p></li><li><p>列表解析：将for循环和创建新元素的代码合并成一行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squares = [value**<span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br></pre></td></tr></table></figure></li><li><p>切片：players[0:3]、players[:4]、players[2:]、players[-3:]</p></li><li><p>复制列表，同时省略起始索引和终止索引（[ : ]）</p></li><li><p>元组是不可变的列表，用圆括号表示</p></li><li><p>不能修改元组的元素，但可以给存储元素的变量赋值</p></li></ol><h2 id="if语句"><a class="markdownIt-Anchor" href="#if语句"></a> if语句</h2><ol><li>使用and和or检查多个条件</li><li>使用in判断特定的值是否已包含在列表中，not in不包含在列表中</li><li>if-elif-else结构</li><li>if语句判断列表时，列表至少包含一个元素返回True，列表为空返回False</li></ol><h2 id="字典"><a class="markdownIt-Anchor" href="#字典"></a> 字典</h2><ol><li>使用del语句删除键-值对</li><li><code>for k, v in user.items()</code>、 <code>for k in user.keys()</code>、<code>for v in user.values()</code></li></ol><h2 id="用户输入和while循环"><a class="markdownIt-Anchor" href="#用户输入和while循环"></a> 用户输入和while循环</h2><ol><li>input()等待用户输入、int()将输入视为数值</li><li>要在遍历列表的同时对其修改，可使用while循环</li></ol><h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2><ol><li>使用def来进行函数定义</li><li>文档字符串：3个引号</li><li>位置实参：实参的顺序和形参的顺序相同；关键字实参：传递给函数的名称-值对；可给每个形参指定默认值</li><li>任意数量的实参：*keys；任意数量的关键字实参：**keys（创建一个keys的空字典）</li><li>模块使扩展名为.py的文件；导入模块import module，调用被导入模块的函数使用module.function()</li><li>导入特定的函数：<code>from module import function1, function2, function3</code></li><li>使用as给函数指定别名：<code>from module import function1 as fn</code>；使用as给模块指定别名：<code>import module as mn</code></li><li>导入模块中所有函数：<code>from module import *</code>（尽量不要，可能重名）</li></ol><h2 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h2><ol><li><p>方法<code>__init__()</code>，通过类创建新实例，会自动运行；形参self必不可少，必须位于最前面，创建实例时，将自动传入实参self：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span></span></span><br></pre></td></tr></table></figure></li><li><p>变量前有self作为前缀，这样的变量称为属性</p></li><li><p>修改属性的值：直接修改属性的值；通过方法修改属性的值；通过方法对属性的值进行递增</p></li><li><p>继承：class SubClass(SuperClass)，在子类的<code>__init__()</code>中调用<code>super().__init__()</code>进行关联</p></li><li><p>从模块导入类：<code>from car import Car, ElectricCar</code></p></li><li><p>导入模块中的所有类：<code>from module import *</code>，这种方式不推荐，因为可能引发名称方面的问题</p></li></ol><h2 id="文件和异常"><a class="markdownIt-Anchor" href="#文件和异常"></a> 文件和异常</h2><ol><li><p><code>open()</code>函数打开文件，关键字with在不再需要访问文件时自动关闭文件，不需要显示调用<code>close()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>) <span class="keyword">as</span> file_obj</span><br></pre></td></tr></table></figure></li><li><p><code>read()</code>读取文件的所有内容，<code>read()</code>到达文件末尾是返回一个空字符串，会显示成一个空行</p></li><li><p>逐行读取：每行的末尾都有一个看不见的换行符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file_obj:</span><br><span class="line"></span><br><span class="line">print(line.rstrip())</span><br></pre></td></tr></table></figure></li><li><p><code>readlines()</code>从文件中读取每一行，并存储在一个列表</p></li><li><p><code>open()</code>两个实参，第一个实参是文件名称，第二个实参是模式：读取模式（‘r’）、写入模式（‘w’）、附加模式（‘a’）、读取和写入模式（‘r+’），默认只读打开文件</p></li><li><p><code>write()</code>不会在你写入的文本末尾添加换行符</p></li><li><p>使用try-except代码块处理异常；try-except-else：try语句放可能引发异常的代码，try成功执行后需要运行的代码放在else代码块</p></li><li><p>pass语句用来在失败时一声不吭</p></li><li><p><code>json.dump()</code>存储数据，两个实参：要存储的数据和可用于存储数据的文件对象；<code>json.load()</code>加载数据文件</p></li></ol><h2 id="测试代码"><a class="markdownIt-Anchor" href="#测试代码"></a> 测试代码</h2><ol><li><p>Python标准库中的模块unittest提供了代码测试工具</p></li><li><p>首先导入unittest模块和要测试的函数或类，创建测试类并在命名中包含Test，这个类必须继承<code>unittest.TestCase</code>类；</p><p>运行测试类时，所有以test_打头的方法都将自动运行；</p><p>使用<strong>断言</strong>方法来核实得到的结果与预期结果是否一致；</p><p><code>unittest.main()</code>运行文件中的测试。</p></li><li><p>常用断言方法：assertEqual(a, b)、assertNotEqual(a, b)、assertTrue(x)、assertFalse(x)、assertIn(item, list)、assertNotIn(item, list)</p></li><li><p>方法setUp()：首先运行，再运行各个test_打头的方法</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript全栈教程-学习笔记1</title>
      <link href="/2018/11/20/JavaScript%E5%85%A8%E6%A0%88%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
      <url>/2018/11/20/JavaScript%E5%85%A8%E6%A0%88%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<p>JavaScript全栈教程-学习笔记系列第一篇</p><ul><li>快速入门</li><li>函数</li><li>标准对象</li></ul><hr><a id="more"></a><h2 id="快速入门"><a class="markdownIt-Anchor" href="#快速入门"></a> 快速入门</h2><ol><li>字符串：模板字符串（ES6新增）</li><li>数组：<ul><li>length赋新值会导致Array大小的变化</li><li><code>slice()</code>、<code>unshift()</code>、<code>shift()</code>、<code>splice()</code>万能方法</li></ul></li><li>对象：<ul><li><code>delete object.prop</code>删除属性</li><li><code>in</code>操作符判断是否有一属性（可能是继承得到的）</li><li><code>hasOwnProperty()</code>是自身拥有的</li></ul></li><li>Map和Set是ES6标准新增的数据类型</li><li>iterable<ul><li>具有iterable类型的集合可以通过<code>for ... of</code>循环来遍历</li><li><code>for ... of</code>循环和<code>for ... in</code>循环的区别：<code>for ... in</code>循环由于历史遗留问题，它遍历的实际上是对象的属性名称;<code>for ... of</code>只循环集合本身的元素</li><li><code>iterable</code>内置的<code>forEach</code>方法</li></ul></li></ol><h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> <strong>函数</strong></h2><ol><li>函数的定义和作用<ul><li>关键字<code>arguments</code>，它只在函数内部使用，指向当前函数的调用者传入的参数。<code>arguments</code>最常用于判断参数的个数</li><li>ES6标准引入了获得额外参数的<code>rest</code>参数，<code>rest</code>参数只能写在最后，前面用…标识</li><li>JavaScript引擎会在行末自动添加分号的机制，如果return语句拆成两行，可能会出错</li></ul></li><li>变量作用域与解构赋值<ul><li>变量提升</li><li>全局作用域：JavaScript默认有一个全局对象<code>window</code>，<code>alert()</code>函数其实也是<code>window</code>的一个变量</li><li>名字空间</li><li>局部作用域：变量作用域实际上是函数内部，为了解决块级作用域，ES6引入了新的关键字<code>let</code></li><li>常量：ES6引入了关键字<code>const</code>来定义常量，<code>const</code>与<code>let</code>都具有块级作用域</li><li>解构赋值，可以同时对一组变量进行赋值</li></ul></li><li>方法<ul><li>方法内部的<code>this</code>可能指向<code>undefined</code>，通过一个<code>that</code>变量首先捕获<code>this</code></li><li>要指定函数的<code>this</code>指向哪个对象，可以用函数本身的<code>apply()</code>。<code>call()</code>与<code>apply()</code>类似，<code>apply()</code>把参数打包<code>Array</code>再传入，<code>call()</code>把参数顺序传入</li></ul></li><li>高阶函数：<code>map()</code>、<code>reduce()</code>、<code>filter()</code>、<code>sort()</code></li><li>闭包（函数作为返回值）<ul><li>返回函数不要引用任何循环变量，或者后续会发生变化的变量</li><li>如果一定要引用循环变量，可以再创建一个函数，用该函数的参数绑定循环变量当前的值</li><li>闭包作用：封装私有变量、把多参数的函数变成单参数的函数</li></ul></li><li>箭头函数（ES6标准）<ul><li>箭头函数和匿名函数的区别：箭头函数内部的<code>this</code>是词法作用域，由上下文确定。</li></ul></li><li>generator<ul><li>generator由<code>function*</code>定义，并且除了<code>return</code>语句，还可以用<code>yield</code>多次返回</li><li>调用generator对象有两个方法，一是不断调用<code>next()</code>方法，每次遇到<code>yield x;</code>，返回一个对象{value: x, done: true/false}；二是直接用<code>for ... of</code>循环迭代generator对象</li><li>generator作用：用一个对象来保存状态；把异步回调代码变成&quot;同步代码&quot;</li></ul></li></ol><h2 id="标准对象"><a class="markdownIt-Anchor" href="#标准对象"></a> 标准对象</h2><ol><li><p><code>null</code>、<code>Array</code>的类型也是<code>object</code>，无法用<code>typeof</code>区分出<code>null</code>、<code>Array</code>和普通的object–<code>{}</code></p></li><li><p>包装对象用<code>new</code>创建，包装对象和原始值用<code>===</code>比较会返回<code>false</code>，所以尽量不要使用包装对象，尤其是针对<code>string</code>类型</p></li><li><p>如果使用<code>Number</code>、<code>Boolean</code>和<code>String</code>时没有写<code>new</code>，<code>Number()</code>、<code>String()</code>等会被当做普通函数，把数据转换为<code>number</code>、<code>boolean</code>和<code>string</code>类型</p></li><li><p>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；用<code>String()</code>来转换任意类型到<code>string</code>，或者调用对象的<code>toString()</code>方法，注意<code>number</code>对象调用<code>toString()</code>报SyntaxError，要特殊处理一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123.</span>.toString();  <span class="comment">//'123'，注意是两个点！</span></span><br><span class="line"></span><br><span class="line">(<span class="number">123</span>).toString();</span><br></pre></td></tr></table></figure></li><li><p><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>、<code>undefined</code>；判断<code>Array</code>要使用<code>Array.isArray(arr)</code>；判断<code>null</code>要使用<code>myVar === null</code></p></li><li><p>判断全局变量是否存在<code>typeof window.myVar === 'undefined'</code>；函数内部变量是否存在使用<code>typeof myVar === 'undefined'</code></p></li><li><p>Date对象月份值从0开始，0=1月…，11=12月</p></li><li><p>创建Date对象的3种方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d2 = <span class="built_in">Date</span>.parse(<span class="string">'2015-06-24T19:49:22.875+08:00'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d3 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1435146562875</span>)</span><br></pre></td></tr></table></figure><p>使用Date.parse()时传入的字符串使用实际月份01<sub>12，转换成Date对象使用getMonth()获取的月份是0</sub>11</p></li><li><p><code>d.toLocaleString()</code>：本地时间，显示的字符串与操作系统设定的格式有关，<code>d.toUTCString()</code>：UTC时间</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>直面Java-面向对象1</title>
      <link href="/2018/09/10/%E7%9B%B4%E9%9D%A2Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11/"/>
      <url>/2018/09/10/%E7%9B%B4%E9%9D%A2Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11/</url>
      
        <content type="html"><![CDATA[<p>这个系列是关于Java基础的知识点，常用于面试。</p><ul><li>面向对象的三大基本特征和五大基本原则</li><li>为什么说Java只有值传递</li><li>Java的编译和反编译方法</li></ul><hr><a id="more"></a><h2 id="面向对象的三大基本特征和五大基本原则"><a class="markdownIt-Anchor" href="#面向对象的三大基本特征和五大基本原则"></a> 面向对象的三大基本特征和五大基本原则</h2><ul><li>三大基本特征：封装、继承、多态</li><li>五大基本原则：单一职责原则（Single-Responsibility Principle）、开放封闭原则（Open-Closed Principle）、Liskov替换原则（Liskov-Substituion Principle）、依赖倒置原则（Dependency-Inversion Principle）和接口隔离原则（Interface-Segregation Principle）<ul><li>单一职责原则：一个类最好只做一件事，只有一个引起它的变化</li><li>开放封闭原则：对扩展开放，对修改封闭</li><li>Liskov替换原则：子类必须能够替换其基类</li><li>依赖倒置原则：依赖于抽象</li><li>接口隔离原则：使用多个小的专门的接口，而不要使用一个大的总接口</li></ul></li></ul><h2 id="为什么说java只有值传递"><a class="markdownIt-Anchor" href="#为什么说java只有值传递"></a> 为什么说Java只有值传递</h2><h4 id="实参和形参"><a class="markdownIt-Anchor" href="#实参和形参"></a> 实参和形参</h4><ul><li>实参是调用有参方法的时候真正传递的内容</li><li>形参数用于接收实参内容的参数</li></ul><h4 id="值传递和引用传递"><a class="markdownIt-Anchor" href="#值传递和引用传递"></a> 值传递和引用传递</h4><ul><li>值传递指调用函数时将实际参数<strong>复制</strong>一份传递到函数中，这样在函数中对参数进行修改，将不会影响到实际参数</li><li>引用传递指调用函数时将实际参数的地址<strong>直接</strong>传递到函数中，那么在函数中对参数进行的修改，将影响到实际参数</li></ul><h4 id="java中的值传递"><a class="markdownIt-Anchor" href="#java中的值传递"></a> Java中的值传递</h4><p>​值传递和引用传递之间区别的重点是：</p><img src="/2018/09/10/直面Java-面向对象1/image1.webp" title="直面Java-面向对象1"><p>举一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   ParamTest pt = <span class="keyword">new</span> ParamTest();</span><br><span class="line"></span><br><span class="line">   User hollis = <span class="keyword">new</span> User();</span><br><span class="line">   hollis.setName(<span class="string">"Hollis"</span>);</span><br><span class="line">   hollis.setGender(<span class="string">"Male"</span>);</span><br><span class="line">   pt.pass(hollis);</span><br><span class="line">   System.out.println(<span class="string">"print in main , user is "</span> + hollis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pass</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">   user = <span class="keyword">new</span> User();</span><br><span class="line">   user.setName(<span class="string">"hollischuang"</span>);</span><br><span class="line">   user.setGender(<span class="string">"Male"</span>);</span><br><span class="line">   System.out.println(<span class="string">"print in pass , user is "</span> + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print in pass , user is User&#123;name=<span class="string">'hollischuang'</span>, gender=<span class="string">'Male'</span>&#125;</span><br><span class="line">print in main , user is User&#123;name=<span class="string">'Hollis'</span>, gender=<span class="string">'Male'</span>&#125;</span><br></pre></td></tr></table></figure><img src="/2018/09/10/直面Java-面向对象1/image2.webp" title="直面Java-面向对象1"><p>从上图分析我们可以得知，这里是把实际参数的引用地址<strong>复制</strong>了一份，传递给了形式参数。<strong>所以，上面的参数其实是值传递，把实际参数引用的地址当做值传递给了形式参数。值传递和引用传递的区别并不是传递的内容，而是实参到底有没有复制一份给形参。</strong></p><p><strong>Java中其实还是值传递，对于对象参数，值的参数是对象的引用。</strong></p><h2 id="java的编译和反编译方法"><a class="markdownIt-Anchor" href="#java的编译和反编译方法"></a> Java的编译和反编译方法</h2><ul><li>编译指的是从高级语言转换成低级语言，将用高级计算机语言所写作的源代码程序，翻译为低阶机器语言的程序的过程就是编译，负责这一过程的工具叫做编译器。</li><li>反编译指的是将已编译好的低阶语言还原到未编译的状态，就是找到程序语言的源代码。Java语言中的反编译一般指将class文件转换成java文件。</li></ul><p>Java语言中负责编译的编译器是一个命令：javac。该工具可以将后缀为.java的源文件编译为后缀为.class的可以运行与Java虚拟机的字节码，再由JVM将这种class文件类型字节码转换成机器可以识别的机器码。</p><p>Java中反编译工具有多个，如<code>javap</code>，<code>jad</code>，<code>CRF</code>：</p><p><strong>javap</strong></p><p><code>javap</code>是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码。<code>javap</code>和其他两个工具最大的区别是它生成的并不是java代码，不像其他两个工具生成的代码那样容易理解。</p><p>源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyc.learn.demo.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchDemoString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"world"</span>;</span><br><span class="line">        <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"hello"</span>:</span><br><span class="line">                System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"world"</span>:</span><br><span class="line">                System.out.println(<span class="string">"world"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>javap -c SwitchDemoString.class</code>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"SwitchDemoString.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">hyc</span>.<span class="title">learn</span>.<span class="title">demo</span>.<span class="title">java</span>.<span class="title">SwitchDemoString</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.hyc.learn.demo.java.SwitchDemoString();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // String world</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: aload_1</span><br><span class="line">       <span class="number">4</span>: astore_2</span><br><span class="line">       <span class="number">5</span>: iconst_m1</span><br><span class="line">       <span class="number">6</span>: istore_3</span><br><span class="line">       <span class="number">7</span>: aload_2</span><br><span class="line">       8: invokevirtual #3                  // Method java/lang/String.hashCode:()I</span><br><span class="line">      <span class="number">11</span>: lookupswitch  &#123; <span class="comment">// 2</span></span><br><span class="line">              <span class="number">99162322</span>: <span class="number">36</span></span><br><span class="line">             <span class="number">113318802</span>: <span class="number">50</span></span><br><span class="line">               <span class="keyword">default</span>: <span class="number">61</span></span><br><span class="line">          &#125;</span><br><span class="line">      <span class="number">36</span>: aload_2</span><br><span class="line">      37: ldc           #4                  // String hello</span><br><span class="line">      39: invokevirtual #5                  // Method java/lang/String.equals:(Ljava/lang/Object;)Z</span><br><span class="line">      <span class="number">42</span>: ifeq          <span class="number">61</span></span><br><span class="line">      <span class="number">45</span>: iconst_0</span><br><span class="line">      <span class="number">46</span>: istore_3</span><br><span class="line">      <span class="number">47</span>: goto          <span class="number">61</span></span><br><span class="line">      <span class="number">50</span>: aload_2</span><br><span class="line">      51: ldc           #2                  // String world</span><br><span class="line">      53: invokevirtual #5                  // Method java/lang/String.equals:(Ljava/lang/Object;)Z</span><br><span class="line">      <span class="number">56</span>: ifeq          <span class="number">61</span></span><br><span class="line">      <span class="number">59</span>: iconst_1</span><br><span class="line">      <span class="number">60</span>: istore_3</span><br><span class="line">      <span class="number">61</span>: iload_3</span><br><span class="line">      <span class="number">62</span>: lookupswitch  &#123; <span class="comment">// 2</span></span><br><span class="line">                     <span class="number">0</span>: <span class="number">88</span></span><br><span class="line">                     <span class="number">1</span>: <span class="number">99</span></span><br><span class="line">               <span class="keyword">default</span>: <span class="number">110</span></span><br><span class="line">          &#125;</span><br><span class="line">      88: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      91: ldc           #4                  // String hello</span><br><span class="line">      93: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">96</span>: goto          <span class="number">110</span></span><br><span class="line">      99: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">     102: ldc           #2                  // String world</span><br><span class="line">     104: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">     <span class="number">107</span>: goto          <span class="number">110</span></span><br><span class="line">     <span class="number">110</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面结果看，<code>javap</code>并没有将字节码反编译成java代码，而是生成了一种我们看得懂的字节码。其实<code>javap</code>生成的文件仍然是字节码。上面的字节码其实是把String转成hashcode，然后进行比较。</p><p><strong>jad</strong></p><p>jad是一个不错的反编译工具，只要下载一个可执行程序，就可以对class文件进行反编译。上面的源代码使用jad反编译结果如下：</p><p>运行命令：<code>jad switchDemoString.class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span></span><br><span class="line"><span class="comment">// Jad home page: http://www.kpdus.com/jad.html</span></span><br><span class="line"><span class="comment">// Decompiler options: packimports(3) </span></span><br><span class="line"><span class="comment">// Source File Name:   SwitchDemoString.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.hyc.learn.demo.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchDemoString</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SwitchDemoString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String str = <span class="string">"world"</span>;</span><br><span class="line">        String s = str;</span><br><span class="line">        <span class="keyword">byte</span> byte0 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(s.hashCode())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">99162322</span>: </span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">"hello"</span>))</span><br><span class="line">                byte0 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">113318802</span>: </span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">"world"</span>))</span><br><span class="line">                byte0 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span>(byte0)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// '\0'</span></span><br><span class="line">            System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// '\001'</span></span><br><span class="line">            System.out.println(<span class="string">"world"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码块就很清晰，很清楚的看到<strong>字符串的switch就是通过<code>equals()</code>和<code>hashcode()</code>方法实现的</strong>。</p><p>但是，jad已经很久没有更新了，官网提示不再更新了，不建议使用了。</p><p><strong>CRF</strong></p><p>jad虽然很好用，但是无奈已经停止更新，所以只能用新的工具去替代它，CFR是一个不错的选择，相比jad，它的语法会稍微复杂一些，但是也可以使用。</p><p>如，对上面的源代码进行反编译，输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar cfr_0_131.jar SwitchDemoString.class  --decodestringswitch false</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decompiled with CFR 0_131.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.hyc.learn.demo.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchDemoString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str;</span><br><span class="line">        String string = str = <span class="string">"world"</span>;</span><br><span class="line">        <span class="keyword">int</span> n = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (string.hashCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">99162322</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (!string.equals(<span class="string">"hello"</span>)) <span class="keyword">break</span>;</span><br><span class="line">                n = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">113318802</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (!string.equals(<span class="string">"world"</span>)) <span class="keyword">break</span>;</span><br><span class="line">                n = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">"world"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的结果也可以看出字符串的switch是用<code>hashcode()</code>和<code>equal()</code>方法实现的。</p><p>和jad相比，CFR有很多参数，上面的代码用以下的命令输出结果就是不一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">java -jar cfr_0_131.jar SwitchDemoString.class</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decompiled with CFR 0_131.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.hyc.learn.demo.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchDemoString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str;</span><br><span class="line">        <span class="keyword">switch</span> (str = <span class="string">"world"</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"hello"</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"world"</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">"world"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数<code>--decodestringswitch</code>表示对于switch支持string的原理进行解码。类似的还有<code>--decodeenumswitch</code>、<code>--decodefinally</code>、<code>--decodelambdas</code>。CFR还有很多其他的参数，可以使用<code>java -jar cfr_0_131.jar --help</code>进行了解</p><p><strong>如何防止反编译</strong></p><p>对于反编译来讲，其实和网络安全的防护，只能提高攻击者的成本而已，并不能彻底防治。</p><p>应对策略有以下几种：</p><ul><li>隔离应用程序<ul><li>让用户接触不到Class文件</li></ul></li><li>对Class文件进行加密<ul><li>提高破解难度</li></ul></li><li>代码混淆<ul><li>将代码转化为功能上等价，但是难以阅读和理解的形式。</li></ul></li></ul><h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接:</h2><p><a href="http://www.hollischuang.com/archives/220" target="_blank" rel="noopener">http://www.hollischuang.com/archives/220</a></p><p><a href="https://mp.weixin.qq.com/s/F7Niaa7nD1tLApCEGKAj4A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/F7Niaa7nD1tLApCEGKAj4A</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一次RabbitMQ线上故障记录</title>
      <link href="/2018/04/19/%E4%B8%80%E6%AC%A1RabbitMQ%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/04/19/%E4%B8%80%E6%AC%A1RabbitMQ%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>今天在线上环境中出现了一个很奇怪的RabbitMQ故障，特意记录下。</p><ul><li>出现现象</li><li>排查过程</li><li>事后分析</li></ul><hr><a id="more"></a><h2 id="出现原因"><a class="markdownIt-Anchor" href="#出现原因"></a> 出现原因</h2><p>由于公司有一个老版本系统在运维，是部署在Windows Server2012的环境上。今天这个系统出现了异常，关于队列有关的功能出现了不可用。因为该系统架构以及代码都比较老旧，而且正在逐步停止运维，定位问题难度比较高。</p><p>具体现象如下：当运维人员发现系统出现异常后，重启了系统，但是还是没有效果。然后查看消息队列RabbitMQ的状态，发现处于停止状态，随后启动RabbitMQ，回到系统一看发现还是不可用。查看系统日志后发现还是无法连接队列，多次启动RabbitMQ，最后发现RabbitMQ无法启动。</p><h2 id="排查过程"><a class="markdownIt-Anchor" href="#排查过程"></a> 排查过程</h2><h3 id="查找日志"><a class="markdownIt-Anchor" href="#查找日志"></a> 查找日志</h3><p>由于多次启动RabbitMQ失败，所以去查看RabbitMQ日志，由于安装RabbitMQ时并未改变日志路径，所以日志输出在默认路径%APPDATA%\RabbitMQ。<br><a href="https://www.rabbitmq.com/relocate.html" target="_blank" rel="noopener">https://www.rabbitmq.com/relocate.html</a></p><img src="/2018/04/19/一次RabbitMQ线上故障记录/一次RabbitMQ线上故障记录-1.png" title="一次RabbitMQ线上故障记录"><h3 id="错误定位"><a class="markdownIt-Anchor" href="#错误定位"></a> 错误定位</h3><p>看日志时发现日志文件已经有600M，无法用Notepad++等工具打开，然后暂时删除日志文件，重启RabbitMQ希望重现问题抓取日志，但是操作几次后从新的日志文件看不出问题。<br>偶然查看磁盘空间，发现剩余0%（0字节可用），因为这台服务器是租用阿里云的资源，磁盘空间有限，可能由于一些不恰当的操作，导致服务器磁盘。<br>删除一些无效文件，使磁盘有空余空间，然后重启RabbitMQ服务，但是查看5672端口还是没有监听。</p><p>因为从Windows服务启动信息不够，暂时先从命令行启动查看，发现错误信息如下：</p><img src="/2018/04/19/一次RabbitMQ线上故障记录/一次RabbitMQ线上故障记录-2.png" title="一次RabbitMQ线上故障记录"><h3 id="处理办法"><a class="markdownIt-Anchor" href="#处理办法"></a> 处理办法</h3><p>由于recovery.dets文件无法加载，导致RabbitMQ无法启动。为了能让系统可用，暂时先删除recovery.dets文件，然后启动RabbitMQ恢复正常。</p><img src="/2018/04/19/一次RabbitMQ线上故障记录/一次RabbitMQ线上故障记录-3.png" title="一次RabbitMQ线上故障记录"><h2 id="事后分析"><a class="markdownIt-Anchor" href="#事后分析"></a> 事后分析</h2><p>查看官方文档，关于RabbitMQ的数据存储：<br>RabbitMQ从3.7.0版本开始所有的消息数据到放在msg_stores/vhosts目录下，每个vhost单独放在一个子目录，每个子目录以 (vhost名字+哈希值).vhost命名，每个vhost分开存储。<br>在3.7.0以前，所有的消息都存在以下几个目录中：queues, msg_store_persistent和msg_store_transient。而且如果正常关机的话，是由recovery.dets文件来恢复元数据。</p><img src="/2018/04/19/一次RabbitMQ线上故障记录/一次RabbitMQ线上故障记录-4.png" title="一次RabbitMQ线上故障记录"><p>下载之前太大的日志，仔细查看ERROR日志，发现如下错误：</p><img src="/2018/04/19/一次RabbitMQ线上故障记录/一次RabbitMQ线上故障记录-5.png" title="一次RabbitMQ线上故障记录"><img src="/2018/04/19/一次RabbitMQ线上故障记录/一次RabbitMQ线上故障记录-6.png" title="一次RabbitMQ线上故障记录"><p>应该是RabbitMQ在关闭时，将队列中的数据写入recovery.dets文件时由于磁盘空间不足，导致文件出现损坏（被删除的recovery.dets文件大小为0），然后RabbitMQ启动时无法从recovery.dets文件获取元数据，所以启动失败。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用kubeadm安装Kubernetes</title>
      <link href="/2018/01/20/kubernetes%E5%AE%89%E8%A3%85/"/>
      <url>/2018/01/20/kubernetes%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>因为业务要求，需要搭建一个容器平台，选择的Kubernetes+Docker搭建集群。<br>Kubernetes有多种安装方式，因为使用的不是Google Cloud和AWS，使用的是阿里云，所以采用kubeadm安装Kubernetes集群。</p><ul><li>准备工作</li><li>安装docker</li><li>安装kubeadm、kubelet、kubectl</li><li>搭建集群</li></ul><hr><a id="more"></a><h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2><p>测试机器： CentOS7.5 （2核4G），3台机器，1台master，2台nodes</p><h3 id="关闭swap"><a class="markdownIt-Anchor" href="#关闭swap"></a> 关闭swap</h3><p>从Kubernetes 1.8开始如果Node上开启了swap，kubelet会启动失败。所以如果服务器是专门用作k8s Node节点的话需要将系统的swap关闭。在测试环境中可以为kubelet加上启动参数<code>--fail-swap-on=false</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ swapoff -a</span><br></pre></td></tr></table></figure><h2 id="安装docker"><a class="markdownIt-Anchor" href="#安装docker"></a> 安装docker</h2><h3 id="安装docker-2"><a class="markdownIt-Anchor" href="#安装docker-2"></a> 安装docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y docker</span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker &amp;&amp; sudo systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="配置docker代理"><a class="markdownIt-Anchor" href="#配置docker代理"></a> 配置docker代理</h3><p>因为后续kubeadm需要下载google镜像，所以为docker配置代理。<br>创建<code>docker.service.d</code>文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p /etc/systemd/system/docker.service.d</span><br></pre></td></tr></table></figure><p>创建一个文件<code>/etc/systemd/system/docker.service.d/http-proxy.conf</code>，包含<code>HTTP_PROXY</code>环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTP_PROXY=http://proxy.example.com:80/"</span></span><br></pre></td></tr></table></figure><p>如果有局域网或者国内的镜像仓库，我们还需要使用<code>NO_PROXY</code>变量声明一下，比如国内的daocloud.io放有镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTP_PROXY=http://proxy.example.com:80/"</span> <span class="string">"NO_PROXY=localhost,127.0.0.1,daocloud.io"</span></span><br></pre></td></tr></table></figure><p>然后重启docker即可</p><h2 id="安装kubeadm-kubelet-kubectl"><a class="markdownIt-Anchor" href="#安装kubeadm-kubelet-kubectl"></a> 安装kubeadm、kubelet、kubectl</h2><h3 id="使用yum安装"><a class="markdownIt-Anchor" href="#使用yum安装"></a> 使用yum安装</h3><p>添加google官方的yum repo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>因为国内无法访问google的yum repo，可以配置阿里云的yum repo，但是阿里云的Kubernetes版本只到1.7.5，不能安装1.7.5以上的Kubernetes版本。<br>注意：此坑极大，之前使用阿里云的yum源，死活安装不了Kubernetes1.9.1。后来通过先升级kubeadm版本，然后使用kubeadm upgrade升级版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后安装kubelet、kubeadm、kubectl</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y kubelet kubeadm kubectl</span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> kubelet &amp;&amp; sudo systemctl start kubelet</span><br></pre></td></tr></table></figure><h3 id="手动安装"><a class="markdownIt-Anchor" href="#手动安装"></a> 手动安装</h3><p>由于google和阿里云yum repo的坑，可以采取手动安装。<br>先将kubeadm、kubelet、kubectl下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://storage.googleapis.com/kubernetes-release/release/v1.9.1/bin/linux/amd64/kubeadm</span><br><span class="line">https://storage.googleapis.com/kubernetes-release/release/v1.9.1/bin/linux/amd64/kubelet</span><br><span class="line">https://storage.googleapis.com/kubernetes-release/release/v1.9.1/bin/linux/amd64/kubectl</span><br></pre></td></tr></table></figure><p>然后将kubeadm、kubelet、kubectl文件上传到节点，复制到/usr/bin目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv kube* /usr/bin</span><br></pre></td></tr></table></figure><p>并为kubelet制作systemd启动服务。<br>创建<code>/etc/systemd/system/kubelet.service</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=kubelet: The Kubernetes Node Agent</span><br><span class="line">Documentation=http://kubernetes.io/docs/</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/kubelet</span><br><span class="line">Restart=always</span><br><span class="line">StartLimitInterval=0</span><br><span class="line">RestartSec=10</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>创建<code>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code>文件，配置kubelet启动参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;KUBELET_KUBECONFIG_ARGS=--kubeconfig=/etc/kubernetes/kubelet.conf --require-kubeconfig=true&quot;</span><br><span class="line">Environment=&quot;KUBELET_SYSTEM_PODS_ARGS=--pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true&quot;</span><br><span class="line">Environment=&quot;KUBELET_NETWORK_ARGS=--network-plugin=cni --cni-conf-dir=/etc/cni/net.d --cni-bin-dir=/opt/cni/bin&quot;</span><br><span class="line">Environment=&quot;KUBELET_DNS_ARGS=--cluster-dns=10.96.0.10 --cluster-domain=cluster.local&quot;</span><br><span class="line">Environment=&quot;KUBELET_AUTHZ_ARGS=--authorization-mode=Webhook --client-ca-file=/etc/kubernetes/pki/ca.crt&quot;</span><br><span class="line">Environment=&quot;KUBELET_CADVISOR_ARGS=--cadvisor-port=0&quot;</span><br><span class="line">Environment=&quot;KUBELET_CGROUP_ARGS=--cgroup-driver=systemd&quot;</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_SYSTEM_PODS_ARGS $KUBELET_DNS_ARGS $KUBELET_AUTHZ_ARGS $KUBELET_CADVISOR_ARGS $KUBELET_CGROUP_ARGS $KUBELET_EXTRA_ARGS</span><br></pre></td></tr></table></figure><h2 id="搭建集群"><a class="markdownIt-Anchor" href="#搭建集群"></a> 搭建集群</h2><h3 id="master节点搭建"><a class="markdownIt-Anchor" href="#master节点搭建"></a> master节点搭建</h3><p>使用kubeadm初始化master节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --kubernetes-version=v1.9.0 --pod-network-cidr==10.244.0.0/16</span><br></pre></td></tr></table></figure><p>然后kubeadm会执行一系列操作，下载镜像，安装etcd和其他控件等等。<br>注意，初始化master节点时一定需要关闭代理，否则会出现网络连接错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> http_proxy</span><br><span class="line"><span class="built_in">unset</span> https_proxy</span><br></pre></td></tr></table></figure><p>如果安装出现错误，可以查看kubelet日志以及服务日志<br>注意：日志这块感觉不是很明确，很难确认问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kubelet logs</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -xe</span><br></pre></td></tr></table></figure><img src="/2018/01/20/kubernetes安装/Kubernetes安装-1.png" title="Kubernetes安装"><img src="/2018/01/20/kubernetes安装/Kubernetes安装-2.png" title="Kubernetes安装"><p>安装完成后，我们还不能使用kubectl来控制集群，要让kubectl可用，还要执行以下步骤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于非root用户</span></span><br><span class="line">$ mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">$ sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">$ sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于root用户</span></span><br><span class="line">$ <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"><span class="comment"># 也可以直接放到~/.bash_profile</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"export KUBECONFIG=/etc/kubernetes/admin.conf"</span> &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure><h3 id="加入nodes"><a class="markdownIt-Anchor" href="#加入nodes"></a> 加入nodes</h3><p>部署完master节点后，就可以增加一些node到我们的集群里<br>ssh到我们的node节点，执行安装后出现的<code>kubeadm join</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm join --token 309e0c.36f306a39b0ac005 172.16.186.72:6443 --discovery-token-ca-cert-hash sha256:3c51d780d36132282d5d3fb0da972619fb7f7b0f2d8fd71c8e89f080cc14433f</span><br></pre></td></tr></table></figure><p>然后，我们去master上输入<code>kubectl get nodes</code>查看就可以看到增加的节点</p><h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接：</h2><p><a href="https://www.kubernetes.org.cn/3357.html" target="_blank" rel="noopener">https://www.kubernetes.org.cn/3357.html</a><br><a href="http://tonybai.com/2017/01/24/explore-kubernetes-cluster-installed-by-kubeadm/" target="_blank" rel="noopener">http://tonybai.com/2017/01/24/explore-kubernetes-cluster-installed-by-kubeadm/</a><br><a href="https://testerhome.com/topics/8668" target="_blank" rel="noopener">https://testerhome.com/topics/8668</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
