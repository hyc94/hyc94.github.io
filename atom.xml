<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hyc的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-21T13:36:49.278Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hyc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript全栈教程-学习笔记1</title>
    <link href="http://yoursite.com/2018/11/20/JavaScript%E5%85%A8%E6%A0%88%E6%95%99%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://yoursite.com/2018/11/20/JavaScript全栈教程-学习笔记1/</id>
    <published>2018-11-20T13:51:24.000Z</published>
    <updated>2018-11-21T13:36:49.278Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript全栈教程-学习笔记系列第一篇</p><ul><li>快速入门</li><li>函数</li></ul><hr><a id="more"></a><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li>字符串：模板字符串（ES6新增）</li><li>数组：<ul><li>length赋新值会导致Array大小的变化</li><li><code>slice()</code>、<code>unshift()</code>、<code>shift()</code>、<code>splice()</code>万能方法</li></ul></li><li>对象：<ul><li><code>delete  object.prop</code>删除属性</li><li><code>in</code>操作符判断是否有一属性（可能是继承得到的）</li><li><code>hasOwnProperty()</code>是自身拥有的</li></ul></li><li>Map和Set是ES6标准新增的数据类型</li><li>iterable<ul><li>具有iterable类型的集合可以通过<code>for ... of</code>循环来遍历</li><li><code>for ... of</code>循环和<code>for ... in</code>循环的区别：<code>for ... in</code>循环由于历史遗留问题，它遍历的实际上是对象的属性名称;<code>for ... of</code>只循环集合本身的元素</li><li><code>iterable</code>内置的<code>forEach</code>方法</li></ul></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h2><ol><li>函数的定义和作用<ul><li>关键字<code>arguments</code>，它只在函数内部使用，指向当前函数的调用者传入的参数。<code>arguments</code>最常用于判断参数的个数</li><li>ES6标准引入了获得额外参数的<code>rest</code>参数，<code>rest</code>参数只能写在最后，前面用…标识</li><li>JavaScript引擎会在行末自动添加分号的机制，如果return语句拆成两行，可能会出错</li></ul></li><li>变量作用域与解构赋值<ul><li>变量提升</li><li>全局作用域：JavaScript默认有一个全局对象<code>window</code>，<code>alert()</code>函数其实也是<code>window</code>的一个变量</li><li>名字空间</li><li>局部作用域：变量作用域实际上是函数内部，为了解决块级作用域，ES6引入了新的关键字<code>let</code></li><li>常量：ES6引入了关键字<code>const</code>来定义常量，<code>const</code>与<code>let</code>都具有块级作用域</li><li>解构赋值，可以同时对一组变量进行赋值</li></ul></li><li>方法<ul><li>方法内部的<code>this</code>可能指向<code>undefined</code>，通过一个<code>that</code>变量首先捕获<code>this</code></li><li>要指定函数的<code>this</code>指向哪个对象，可以用函数本身的<code>apply()</code>。<code>call()</code>与<code>apply()</code>类似，<code>apply()</code>把参数打包<code>Array</code>再传入，<code>call()</code>把参数顺序传入</li></ul></li><li>高阶函数：<code>map()</code>、<code>reduce()</code>、<code>filter()</code>、<code>sort()</code></li><li>闭包（函数作为返回值）<ul><li>返回函数不要引用任何循环变量，或者后续会发生变化的变量</li><li>如果一定要引用循环变量，可以再创建一个函数，用该函数的参数绑定循环变量当前的值</li><li>闭包作用：封装私有变量、把多参数的函数变成单参数的函数</li></ul></li><li>箭头函数（ES6标准）<ul><li>箭头函数和匿名函数的区别：箭头函数内部的<code>this</code>是词法作用域，由上下文确定。</li></ul></li><li>generator<ul><li>generator由<code>function*</code>定义，并且除了<code>return</code>语句，还可以用<code>yield</code>多次返回</li><li>调用generator对象有两个方法，一是不断调用<code>next()</code>方法，每次遇到<code>yield x;</code>，返回一个对象{value: x, done: true/false}；二是直接用<code>for ... of</code>循环迭代generator对象</li><li>generator作用：用一个对象来保存状态；把异步回调代码变成”同步代码”</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript全栈教程-学习笔记系列第一篇&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速入门&lt;/li&gt;
&lt;li&gt;函数&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>直面Java-面向对象1</title>
    <link href="http://yoursite.com/2018/09/10/%E7%9B%B4%E9%9D%A2Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11/"/>
    <id>http://yoursite.com/2018/09/10/直面Java-面向对象1/</id>
    <published>2018-09-10T14:15:24.000Z</published>
    <updated>2018-11-21T13:36:41.584Z</updated>
    
    <content type="html"><![CDATA[<p>这个系列是关于Java基础的知识点，常用于面试。</p><ul><li>面向对象的三大基本特征和五大基本原则</li><li>为什么说Java只有值传递</li><li>Java的编译和反编译方法</li></ul><hr><a id="more"></a><h2 id="面向对象的三大基本特征和五大基本原则"><a href="#面向对象的三大基本特征和五大基本原则" class="headerlink" title="面向对象的三大基本特征和五大基本原则"></a>面向对象的三大基本特征和五大基本原则</h2><ul><li>三大基本特征：封装、继承、多态</li><li>五大基本原则：单一职责原则（Single-Responsibility Principle）、开放封闭原则（Open-Closed Principle）、Liskov替换原则（Liskov-Substituion Principle）、依赖倒置原则（Dependency-Inversion Principle）和接口隔离原则（Interface-Segregation Principle）<ul><li>单一职责原则：一个类最好只做一件事，只有一个引起它的变化</li><li>开放封闭原则：对扩展开放，对修改封闭</li><li>Liskov替换原则：子类必须能够替换其基类</li><li>依赖倒置原则：依赖于抽象</li><li>接口隔离原则：使用多个小的专门的接口，而不要使用一个大的总接口</li></ul></li></ul><h2 id="为什么说Java只有值传递"><a href="#为什么说Java只有值传递" class="headerlink" title="为什么说Java只有值传递"></a>为什么说Java只有值传递</h2><h4 id="实参和形参"><a href="#实参和形参" class="headerlink" title="实参和形参"></a>实参和形参</h4><ul><li>实参是调用有参方法的时候真正传递的内容</li><li>形参数用于接收实参内容的参数</li></ul><h4 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h4><ul><li>值传递指调用函数时将实际参数<strong>复制</strong>一份传递到函数中，这样在函数中对参数进行修改，将不会影响到实际参数</li><li>引用传递指调用函数时将实际参数的地址<strong>直接</strong>传递到函数中，那么在函数中对参数进行的修改，将影响到实际参数</li></ul><h4 id="Java中的值传递"><a href="#Java中的值传递" class="headerlink" title="Java中的值传递"></a>Java中的值传递</h4><p>​    值传递和引用传递之间区别的重点是：</p><img src="/2018/09/10/直面Java-面向对象1/image1.webp" title="直面Java-面向对象1"><p>举一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   ParamTest pt = <span class="keyword">new</span> ParamTest();</span><br><span class="line"></span><br><span class="line">   User hollis = <span class="keyword">new</span> User();</span><br><span class="line">   hollis.setName(<span class="string">"Hollis"</span>);</span><br><span class="line">   hollis.setGender(<span class="string">"Male"</span>);</span><br><span class="line">   pt.pass(hollis);</span><br><span class="line">   System.out.println(<span class="string">"print in main , user is "</span> + hollis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pass</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">   user = <span class="keyword">new</span> User();</span><br><span class="line">   user.setName(<span class="string">"hollischuang"</span>);</span><br><span class="line">   user.setGender(<span class="string">"Male"</span>);</span><br><span class="line">   System.out.println(<span class="string">"print in pass , user is "</span> + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print in pass , user is User&#123;name=<span class="string">'hollischuang'</span>, gender=<span class="string">'Male'</span>&#125;</span><br><span class="line">print in main , user is User&#123;name=<span class="string">'Hollis'</span>, gender=<span class="string">'Male'</span>&#125;</span><br></pre></td></tr></table></figure><img src="/2018/09/10/直面Java-面向对象1/image2.webp" title="直面Java-面向对象1"><p>从上图分析我们可以得知，这里是把实际参数的引用地址<strong>复制</strong>了一份，传递给了形式参数。<strong>所以，上面的参数其实是值传递，把实际参数引用的地址当做值传递给了形式参数。值传递和引用传递的区别并不是传递的内容，而是实参到底有没有复制一份给形参。</strong></p><p><strong>Java中其实还是值传递，对于对象参数，值的参数是对象的引用。</strong></p><h2 id="Java的编译和反编译方法"><a href="#Java的编译和反编译方法" class="headerlink" title="Java的编译和反编译方法"></a>Java的编译和反编译方法</h2><ul><li>编译指的是从高级语言转换成低级语言，将用高级计算机语言所写作的源代码程序，翻译为低阶机器语言的程序的过程就是编译，负责这一过程的工具叫做编译器。</li><li>反编译指的是将已编译好的低阶语言还原到未编译的状态，就是找到程序语言的源代码。Java语言中的反编译一般指将class文件转换成java文件。</li></ul><p>Java语言中负责编译的编译器是一个命令：javac。该工具可以将后缀为.java的源文件编译为后缀为.class的可以运行与Java虚拟机的字节码，再由JVM将这种class文件类型字节码转换成机器可以识别的机器码。</p><p>Java中反编译工具有多个，如<code>javap</code>，<code>jad</code>，<code>CRF</code>：</p><p><strong>javap</strong></p><p><code>javap</code>是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码。<code>javap</code>和其他两个工具最大的区别是它生成的并不是java代码，不像其他两个工具生成的代码那样容易理解。</p><p>源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hyc.learn.demo.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchDemoString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"world"</span>;</span><br><span class="line">        <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"hello"</span>:</span><br><span class="line">                System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"world"</span>:</span><br><span class="line">                System.out.println(<span class="string">"world"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>javap -c SwitchDemoString.class</code>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"SwitchDemoString.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">hyc</span>.<span class="title">learn</span>.<span class="title">demo</span>.<span class="title">java</span>.<span class="title">SwitchDemoString</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.hyc.learn.demo.java.SwitchDemoString();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // String world</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: aload_1</span><br><span class="line">       <span class="number">4</span>: astore_2</span><br><span class="line">       <span class="number">5</span>: iconst_m1</span><br><span class="line">       <span class="number">6</span>: istore_3</span><br><span class="line">       <span class="number">7</span>: aload_2</span><br><span class="line">       8: invokevirtual #3                  // Method java/lang/String.hashCode:()I</span><br><span class="line">      <span class="number">11</span>: lookupswitch  &#123; <span class="comment">// 2</span></span><br><span class="line">              <span class="number">99162322</span>: <span class="number">36</span></span><br><span class="line">             <span class="number">113318802</span>: <span class="number">50</span></span><br><span class="line">               <span class="keyword">default</span>: <span class="number">61</span></span><br><span class="line">          &#125;</span><br><span class="line">      <span class="number">36</span>: aload_2</span><br><span class="line">      37: ldc           #4                  // String hello</span><br><span class="line">      39: invokevirtual #5                  // Method java/lang/String.equals:(Ljava/lang/Object;)Z</span><br><span class="line">      <span class="number">42</span>: ifeq          <span class="number">61</span></span><br><span class="line">      <span class="number">45</span>: iconst_0</span><br><span class="line">      <span class="number">46</span>: istore_3</span><br><span class="line">      <span class="number">47</span>: goto          <span class="number">61</span></span><br><span class="line">      <span class="number">50</span>: aload_2</span><br><span class="line">      51: ldc           #2                  // String world</span><br><span class="line">      53: invokevirtual #5                  // Method java/lang/String.equals:(Ljava/lang/Object;)Z</span><br><span class="line">      <span class="number">56</span>: ifeq          <span class="number">61</span></span><br><span class="line">      <span class="number">59</span>: iconst_1</span><br><span class="line">      <span class="number">60</span>: istore_3</span><br><span class="line">      <span class="number">61</span>: iload_3</span><br><span class="line">      <span class="number">62</span>: lookupswitch  &#123; <span class="comment">// 2</span></span><br><span class="line">                     <span class="number">0</span>: <span class="number">88</span></span><br><span class="line">                     <span class="number">1</span>: <span class="number">99</span></span><br><span class="line">               <span class="keyword">default</span>: <span class="number">110</span></span><br><span class="line">          &#125;</span><br><span class="line">      88: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      91: ldc           #4                  // String hello</span><br><span class="line">      93: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">96</span>: goto          <span class="number">110</span></span><br><span class="line">      99: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">     102: ldc           #2                  // String world</span><br><span class="line">     104: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">     <span class="number">107</span>: goto          <span class="number">110</span></span><br><span class="line">     <span class="number">110</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面结果看，<code>javap</code>并没有将字节码反编译成java代码，而是生成了一种我们看得懂的字节码。其实<code>javap</code>生成的文件仍然是字节码。上面的字节码其实是把String转成hashcode，然后进行比较。</p><p><strong>jad</strong></p><p>jad是一个不错的反编译工具，只要下载一个可执行程序，就可以对class文件进行反编译。上面的源代码使用jad反编译结果如下：</p><p>运行命令：<code>jad switchDemoString.class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span></span><br><span class="line"><span class="comment">// Jad home page: http://www.kpdus.com/jad.html</span></span><br><span class="line"><span class="comment">// Decompiler options: packimports(3) </span></span><br><span class="line"><span class="comment">// Source File Name:   SwitchDemoString.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.hyc.learn.demo.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchDemoString</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SwitchDemoString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String str = <span class="string">"world"</span>;</span><br><span class="line">        String s = str;</span><br><span class="line">        <span class="keyword">byte</span> byte0 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(s.hashCode())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">99162322</span>: </span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">"hello"</span>))</span><br><span class="line">                byte0 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">113318802</span>: </span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">"world"</span>))</span><br><span class="line">                byte0 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span>(byte0)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// '\0'</span></span><br><span class="line">            System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// '\001'</span></span><br><span class="line">            System.out.println(<span class="string">"world"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个代码块就很清晰，很清楚的看到<strong>字符串的switch就是通过<code>equals()</code>和<code>hashcode()</code>方法实现的</strong>。</p><p>但是，jad已经很久没有更新了，官网提示不再更新了，不建议使用了。</p><p><strong>CRF</strong></p><p>jad虽然很好用，但是无奈已经停止更新，所以只能用新的工具去替代它，CFR是一个不错的选择，相比jad，它的语法会稍微复杂一些，但是也可以使用。</p><p>如，对上面的源代码进行反编译，输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar cfr_0_131.jar SwitchDemoString.class  --decodestringswitch false</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decompiled with CFR 0_131.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.hyc.learn.demo.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchDemoString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str;</span><br><span class="line">        String string = str = <span class="string">"world"</span>;</span><br><span class="line">        <span class="keyword">int</span> n = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (string.hashCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">99162322</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (!string.equals(<span class="string">"hello"</span>)) <span class="keyword">break</span>;</span><br><span class="line">                n = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">113318802</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (!string.equals(<span class="string">"world"</span>)) <span class="keyword">break</span>;</span><br><span class="line">                n = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">"world"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的结果也可以看出字符串的switch是用<code>hashcode()</code>和<code>equal()</code>方法实现的。</p><p>和jad相比，CFR有很多参数，上面的代码用以下的命令输出结果就是不一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">java -jar cfr_0_131.jar SwitchDemoString.class</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decompiled with CFR 0_131.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.hyc.learn.demo.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchDemoString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str;</span><br><span class="line">        <span class="keyword">switch</span> (str = <span class="string">"world"</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"hello"</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"world"</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">"world"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数<code>--decodestringswitch</code>表示对于switch支持string的原理进行解码。类似的还有<code>--decodeenumswitch</code>、<code>--decodefinally</code>、<code>--decodelambdas</code>。CFR还有很多其他的参数，可以使用<code>java -jar cfr_0_131.jar --help</code>进行了解</p><p><strong>如何防止反编译</strong></p><p>对于反编译来讲，其实和网络安全的防护，只能提高攻击者的成本而已，并不能彻底防治。</p><p>应对策略有以下几种：</p><ul><li>隔离应用程序<ul><li>让用户接触不到Class文件</li></ul></li><li>对Class文件进行加密<ul><li>提高破解难度</li></ul></li><li>代码混淆<ul><li>将代码转化为功能上等价，但是难以阅读和理解的形式。</li></ul></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h2><p><a href="http://www.hollischuang.com/archives/220" target="_blank" rel="noopener">http://www.hollischuang.com/archives/220</a></p><p><a href="https://mp.weixin.qq.com/s/F7Niaa7nD1tLApCEGKAj4A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/F7Niaa7nD1tLApCEGKAj4A</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个系列是关于Java基础的知识点，常用于面试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向对象的三大基本特征和五大基本原则&lt;/li&gt;
&lt;li&gt;为什么说Java只有值传递&lt;/li&gt;
&lt;li&gt;Java的编译和反编译方法&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>一次RabbitMQ线上故障记录</title>
    <link href="http://yoursite.com/2018/04/19/%E4%B8%80%E6%AC%A1RabbitMQ%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/04/19/一次RabbitMQ线上故障记录/</id>
    <published>2018-04-19T13:08:49.000Z</published>
    <updated>2018-11-21T13:37:20.475Z</updated>
    
    <content type="html"><![CDATA[<p>今天在线上环境中出现了一个很奇怪的RabbitMQ故障，特意记录下。</p><ul><li>出现现象</li><li>排查过程</li><li>事后分析</li></ul><hr><a id="more"></a><h2 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h2><p>由于公司有一个老版本系统在运维，是部署在Windows Server2012的环境上。今天这个系统出现了异常，关于队列有关的功能出现了不可用。因为该系统架构以及代码都比较老旧，而且正在逐步停止运维，定位问题难度比较高。</p><p>具体现象如下：当运维人员发现系统出现异常后，重启了系统，但是还是没有效果。然后查看消息队列RabbitMQ的状态，发现处于停止状态，随后启动RabbitMQ，回到系统一看发现还是不可用。查看系统日志后发现还是无法连接队列，多次启动RabbitMQ，最后发现RabbitMQ无法启动。</p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="查找日志"><a href="#查找日志" class="headerlink" title="查找日志"></a>查找日志</h3><p>由于多次启动RabbitMQ失败，所以去查看RabbitMQ日志，由于安装RabbitMQ时并未改变日志路径，所以日志输出在默认路径    %APPDATA%\RabbitMQ。<br><a href="https://www.rabbitmq.com/relocate.html" target="_blank" rel="noopener">https://www.rabbitmq.com/relocate.html</a><br><img src="/2018/04/19/一次RabbitMQ线上故障记录/一次RabbitMQ线上故障记录-1.png" title="一次RabbitMQ线上故障记录"></p><h3 id="错误定位"><a href="#错误定位" class="headerlink" title="错误定位"></a>错误定位</h3><p>看日志时发现日志文件已经有600M，无法用Notepad++等工具打开，然后暂时删除日志文件，重启RabbitMQ希望重现问题抓取日志，但是操作几次后从新的日志文件看不出问题。<br>偶然查看磁盘空间，发现剩余0%（0字节可用），因为这台服务器是租用阿里云的资源，磁盘空间有限，可能由于一些不恰当的操作，导致服务器磁盘。<br>删除一些无效文件，使磁盘有空余空间，然后重启RabbitMQ服务，但是查看5672端口还是没有监听。</p><p>因为从Windows服务启动信息不够，暂时先从命令行启动查看，发现错误信息如下：<br><img src="/2018/04/19/一次RabbitMQ线上故障记录/一次RabbitMQ线上故障记录-2.png" title="一次RabbitMQ线上故障记录"></p><h3 id="处理办法"><a href="#处理办法" class="headerlink" title="处理办法"></a>处理办法</h3><p>由于recovery.dets文件无法加载，导致RabbitMQ无法启动。为了能让系统可用，暂时先删除recovery.dets文件，然后启动RabbitMQ恢复正常。<br><img src="/2018/04/19/一次RabbitMQ线上故障记录/一次RabbitMQ线上故障记录-3.png" title="一次RabbitMQ线上故障记录"></p><h2 id="事后分析"><a href="#事后分析" class="headerlink" title="事后分析"></a>事后分析</h2><p>查看官方文档，关于RabbitMQ的数据存储：<br>RabbitMQ从3.7.0版本开始所有的消息数据到放在msg_stores/vhosts目录下，每个vhost单独放在一个子目录，每个子目录以 (vhost名字+哈希值).vhost命名，每个vhost分开存储。<br>在3.7.0以前，所有的消息都存在以下几个目录中：queues, msg_store_persistent和msg_store_transient。而且如果正常关机的话，是由recovery.dets文件来恢复元数据。<br><img src="/2018/04/19/一次RabbitMQ线上故障记录/一次RabbitMQ线上故障记录-4.png" title="一次RabbitMQ线上故障记录"></p><p>下载之前太大的日志，仔细查看ERROR日志，发现如下错误：<br><img src="/2018/04/19/一次RabbitMQ线上故障记录/一次RabbitMQ线上故障记录-5.png" title="一次RabbitMQ线上故障记录"><br><img src="/2018/04/19/一次RabbitMQ线上故障记录/一次RabbitMQ线上故障记录-6.png" title="一次RabbitMQ线上故障记录"></p><p>应该是RabbitMQ在关闭时，将队列中的数据写入recovery.dets文件时由于磁盘空间不足，导致文件出现损坏（被删除的recovery.dets文件大小为0），然后RabbitMQ启动时无法从recovery.dets文件获取元数据，所以启动失败。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在线上环境中出现了一个很奇怪的RabbitMQ故障，特意记录下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;出现现象&lt;/li&gt;
&lt;li&gt;排查过程&lt;/li&gt;
&lt;li&gt;事后分析&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="运维" scheme="http://yoursite.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="mq" scheme="http://yoursite.com/tags/mq/"/>
    
  </entry>
  
  <entry>
    <title>使用kubeadm安装Kubernetes</title>
    <link href="http://yoursite.com/2018/01/20/kubernetes%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2018/01/20/kubernetes安装/</id>
    <published>2018-01-20T13:51:24.000Z</published>
    <updated>2018-11-21T14:30:31.344Z</updated>
    
    <content type="html"><![CDATA[<p>因为业务要求，需要搭建一个容器平台，选择的Kubernetes+Docker搭建集群。<br>Kubernetes有多种安装方式，因为使用的不是Google Cloud和AWS，使用的是阿里云，所以采用kubeadm安装Kubernetes集群。</p><ul><li>准备工作</li><li>安装docker</li><li>安装kubeadm、kubelet、kubectl</li><li>搭建集群</li></ul><hr><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>测试机器： CentOS7.5 （2核4G），3台机器，1台master，2台nodes</p><h3 id="关闭swap"><a href="#关闭swap" class="headerlink" title="关闭swap"></a>关闭swap</h3><p>从Kubernetes 1.8开始如果Node上开启了swap，kubelet会启动失败。所以如果服务器是专门用作k8s Node节点的话需要将系统的swap关闭。在测试环境中可以为kubelet加上启动参数<code>--fail-swap-on=false</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ swapoff -a</span><br></pre></td></tr></table></figure></p><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><h3 id="安装docker-1"><a href="#安装docker-1" class="headerlink" title="安装docker"></a>安装docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y docker</span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker &amp;&amp; sudo systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="配置docker代理"><a href="#配置docker代理" class="headerlink" title="配置docker代理"></a>配置docker代理</h3><p>因为后续kubeadm需要下载google镜像，所以为docker配置代理。<br>创建<code>docker.service.d</code>文件夹<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p /etc/systemd/system/docker.service.d</span><br></pre></td></tr></table></figure></p><p>创建一个文件<code>/etc/systemd/system/docker.service.d/http-proxy.conf</code>，包含<code>HTTP_PROXY</code>环境变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTP_PROXY=http://proxy.example.com:80/"</span></span><br></pre></td></tr></table></figure></p><p>如果有局域网或者国内的镜像仓库，我们还需要使用<code>NO_PROXY</code>变量声明一下，比如国内的daocloud.io放有镜像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTP_PROXY=http://proxy.example.com:80/"</span> <span class="string">"NO_PROXY=localhost,127.0.0.1,daocloud.io"</span></span><br></pre></td></tr></table></figure></p><p>然后重启docker即可</p><h2 id="安装kubeadm、kubelet、kubectl"><a href="#安装kubeadm、kubelet、kubectl" class="headerlink" title="安装kubeadm、kubelet、kubectl"></a>安装kubeadm、kubelet、kubectl</h2><h3 id="使用yum安装"><a href="#使用yum安装" class="headerlink" title="使用yum安装"></a>使用yum安装</h3><p>添加google官方的yum repo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>因为国内无法访问google的yum repo，可以配置阿里云的yum repo，但是阿里云的Kubernetes版本只到1.7.5，不能安装1.7.5以上的Kubernetes版本。<br>注意：此坑极大，之前使用阿里云的yum源，死活安装不了Kubernetes1.9.1。后来通过先升级kubeadm版本，然后使用kubeadm upgrade升级版本。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>然后安装kubelet、kubeadm、kubectl<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y kubelet kubeadm kubectl</span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> kubelet &amp;&amp; sudo systemctl start kubelet</span><br></pre></td></tr></table></figure></p><h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><p>由于google和阿里云yum repo的坑，可以采取手动安装。<br>先将kubeadm、kubelet、kubectl下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://storage.googleapis.com/kubernetes-release/release/v1.9.1/bin/linux/amd64/kubeadm</span><br><span class="line">https://storage.googleapis.com/kubernetes-release/release/v1.9.1/bin/linux/amd64/kubelet</span><br><span class="line">https://storage.googleapis.com/kubernetes-release/release/v1.9.1/bin/linux/amd64/kubectl</span><br></pre></td></tr></table></figure></p><p>然后将kubeadm、kubelet、kubectl文件上传到节点，复制到/usr/bin目录下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv kube* /usr/bin</span><br></pre></td></tr></table></figure></p><p>并为kubelet制作systemd启动服务。<br>创建<code>/etc/systemd/system/kubelet.service</code>文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=kubelet: The Kubernetes Node Agent</span><br><span class="line">Documentation=http://kubernetes.io/docs/</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/kubelet</span><br><span class="line">Restart=always</span><br><span class="line">StartLimitInterval=0</span><br><span class="line">RestartSec=10</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p><p>创建<code>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code>文件，配置kubelet启动参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;KUBELET_KUBECONFIG_ARGS=--kubeconfig=/etc/kubernetes/kubelet.conf --require-kubeconfig=true&quot;</span><br><span class="line">Environment=&quot;KUBELET_SYSTEM_PODS_ARGS=--pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true&quot;</span><br><span class="line">Environment=&quot;KUBELET_NETWORK_ARGS=--network-plugin=cni --cni-conf-dir=/etc/cni/net.d --cni-bin-dir=/opt/cni/bin&quot;</span><br><span class="line">Environment=&quot;KUBELET_DNS_ARGS=--cluster-dns=10.96.0.10 --cluster-domain=cluster.local&quot;</span><br><span class="line">Environment=&quot;KUBELET_AUTHZ_ARGS=--authorization-mode=Webhook --client-ca-file=/etc/kubernetes/pki/ca.crt&quot;</span><br><span class="line">Environment=&quot;KUBELET_CADVISOR_ARGS=--cadvisor-port=0&quot;</span><br><span class="line">Environment=&quot;KUBELET_CGROUP_ARGS=--cgroup-driver=systemd&quot;</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_SYSTEM_PODS_ARGS $KUBELET_DNS_ARGS $KUBELET_AUTHZ_ARGS $KUBELET_CADVISOR_ARGS $KUBELET_CGROUP_ARGS $KUBELET_EXTRA_ARGS</span><br></pre></td></tr></table></figure></p><h2 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h2><h3 id="master节点搭建"><a href="#master节点搭建" class="headerlink" title="master节点搭建"></a>master节点搭建</h3><p>使用kubeadm初始化master节点<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --kubernetes-version=v1.9.0 --pod-network-cidr==10.244.0.0/16</span><br></pre></td></tr></table></figure></p><p>然后kubeadm会执行一系列操作，下载镜像，安装etcd和其他控件等等。<br>注意，初始化master节点时一定需要关闭代理，否则会出现网络连接错误<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> http_proxy</span><br><span class="line"><span class="built_in">unset</span> https_proxy</span><br></pre></td></tr></table></figure></p><p>如果安装出现错误，可以查看kubelet日志以及服务日志<br>注意：日志这块感觉不是很明确，很难确认问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kubelet logs</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -xe</span><br></pre></td></tr></table></figure><img src="/2018/01/20/kubernetes安装/Kubernetes安装-1.png" title="Kubernetes安装"><img src="/2018/01/20/kubernetes安装/Kubernetes安装-2.png" title="Kubernetes安装"><p>安装完成后，我们还不能使用kubectl来控制集群，要让kubectl可用，还要执行以下步骤<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于非root用户</span></span><br><span class="line">$ mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">$ sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">$ sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于root用户</span></span><br><span class="line">$ <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"><span class="comment"># 也可以直接放到~/.bash_profile</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"export KUBECONFIG=/etc/kubernetes/admin.conf"</span> &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure></p><h3 id="加入nodes"><a href="#加入nodes" class="headerlink" title="加入nodes"></a>加入nodes</h3><p>部署完master节点后，就可以增加一些node到我们的集群里<br>ssh到我们的node节点，执行安装后出现的<code>kubeadm join</code>命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm join --token 309e0c.36f306a39b0ac005 172.16.186.72:6443 --discovery-token-ca-cert-hash sha256:3c51d780d36132282d5d3fb0da972619fb7f7b0f2d8fd71c8e89f080cc14433f</span><br></pre></td></tr></table></figure></p><p>然后，我们去master上输入<code>kubectl get nodes</code>查看就可以看到增加的节点</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://www.kubernetes.org.cn/3357.html" target="_blank" rel="noopener">https://www.kubernetes.org.cn/3357.html</a><br><a href="http://tonybai.com/2017/01/24/explore-kubernetes-cluster-installed-by-kubeadm/" target="_blank" rel="noopener">http://tonybai.com/2017/01/24/explore-kubernetes-cluster-installed-by-kubeadm/</a><br><a href="https://testerhome.com/topics/8668" target="_blank" rel="noopener">https://testerhome.com/topics/8668</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为业务要求，需要搭建一个容器平台，选择的Kubernetes+Docker搭建集群。&lt;br&gt;Kubernetes有多种安装方式，因为使用的不是Google Cloud和AWS，使用的是阿里云，所以采用kubeadm安装Kubernetes集群。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;准备工作&lt;/li&gt;
&lt;li&gt;安装docker&lt;/li&gt;
&lt;li&gt;安装kubeadm、kubelet、kubectl&lt;/li&gt;
&lt;li&gt;搭建集群&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="运维" scheme="http://yoursite.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="devops" scheme="http://yoursite.com/tags/devops/"/>
    
  </entry>
  
</feed>
